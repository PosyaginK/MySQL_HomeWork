#################################################################################################################################
#################################################################################################################################
/* Практическое задание по теме “Транзакции, переменные, представления”*/
#################################################################################################################################
#################################################################################################################################


#################################################################################################################################
/* 1. В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. Переместите запись id = 1 из таблицы 
 * shop.users в таблицу sample.users. Используйте транзакции.*/
#################################################################################################################################

CREATE DATABASE sample;
USE sample
; 

DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`(
	id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(255),
	birthday_at DATE,
	created_at DATETIME DEFAULT NOW(),
	updated_at DATETIME DEFAULT NOW()
)
;
-- Начинаем транзакцию
START TRANSACTION
;
-- Проверим наличие записи с id = 1
SELECT * FROM shop.users WHERE id = 1
;
-- Вставим запись из shop.users в sample.users, где id = 1
INSERT INTO sample.users (`id`, `name`, `birthday_at`, `created_at`, `updated_at`) 
SELECT `id`, `name`, `birthday_at`, `created_at`, `updated_at`
FROM shop.users 
WHERE `id` = 1
;
-- Удалим запись из shop.users
DELETE FROM shop.users WHERE id = 1
;
-- Завершим транзакцию
COMMIT
;

#################################################################################################################################
/* 2. Создайте представление, которое выводит название name товарной позиции из таблицы products и соответствующее название 
 * каталога name из таблицы catalogs.*/
#################################################################################################################################

USE shop;
-- Cоздаем представление
CREATE VIEW prod_cat (`product`, `catalog`) 
AS 
SELECT p.name, c.name 
FROM products p
	JOIN catalogs c
	ON p.catalog_id = c.id
;
-- Можем посмотреть содержимое
SELECT * FROM prod_cat;

#################################################################################################################################
/* 3. Пусть имеется таблица с календарным полем created_at. В ней размещены разряженые календарные записи за август 2018 года 
 * '2018-08-01', '2016-08-04', '2018-08-16' и 2018-08-17. Составьте запрос, который выводит полный список дат за август, 
 * выставляя в соседнем поле значение 1, если дата присутствует в исходном таблице и 0, если она отсутствует.*/
#################################################################################################################################

USE example;
-- Создаю таблицу с датами
DROP TABLE IF EXISTS `dates`;
CREATE TABLE `dates` (
	created_at DATE);
-- Заполняю её
INSERT INTO `dates`
VALUES
	('2018-08-01'), ('2016-08-04'), ('2018-08-16'), ('2018-08-17')
;
-- Создаю временную таблицу для вывода списка дат за август.
CREATE TEMPORARY TABLE `aug` (
	days INT);
-- Заполняю числами 1 - 31
INSERT INTO `aug`
VALUES
	(1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12),(13),(14), (15), 
	(16), (17), (18), (19), (20), (21), (22), (23), (24), (25), (26), (27), (28), (29), (30), (31)
;
-- Устанавливаю дату начала отчета (т.к. в таблице `aug` я начал отчет с 1, то первая дата будет 31 июля)
SET @start_aug = '2018-07-31';

SELECT @start_aug + INTERVAL `days` DAY AS `Дата`, -- Выводжу даты августа путем прибавления к изначальной дате `days` дней.
	CASE 
	WHEN -- устанавливаю условие, что если значение даты в таблице `dates` - NULL (то есть ее там нет), то выводим 0
		dates.created_at IS NULL THEN 0
	ELSE 1 END as `1/0` FROM `aug` -- Иначе выводим 1
LEFT JOIN `dates` -- Использую LEFT JOIN, чтобы выводились все даты августа, а не только те, что есть в таблице `dates`.
ON @start_aug + INTERVAL `days` DAY = dates.created_at
ORDER BY `Дата` -- Сортирую по порядку.
;

################################################################################################################################# 
/* 4. Пусть имеется любая таблица с календарным полем created_at. Создайте запрос, который удаляет устаревшие записи из таблицы, 
 * оставляя только 5 самых свежих записей.*/
#################################################################################################################################

USE shop;
-- Пересоздам таблицу users в базе данных shop
DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at DATE,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Покупатели';
-- Заполню ее данными, включая дату создания (created_at)
INSERT INTO users (name, birthday_at, created_at) VALUES
  ('Геннадий', '1990-10-05', '2020-02-17'),
  ('Наталья', '1984-11-12', '2014-05-15'),
  ('Александр', '1985-05-20', '2018-06-17'),
  ('Сергей', '1988-02-14', '2016-11-10'),
  ('Иван', '1998-01-12', '2019-07-12'),
  ('Мария', '1992-08-29', '2021-09-17'),
  ('Елена', '1994-10-15', '2015-03-17');
 
 SELECT * FROM users ORDER BY created_at DESC;

 -- Создаю запрос 
PREPARE last_five 
FROM 
'DELETE FROM users ORDER BY created_at LIMIT ?';
SET @CNT = (SELECT COUNT(*)-5 FROM users);
EXECUTE last_five USING @CNT;

SELECT * FROM users ORDER BY created_at DESC;


#################################################################################################################################
#################################################################################################################################
/*Практическое задание по теме “Администрирование MySQL” (эта тема изучается по вашему желанию)*/
#################################################################################################################################
#################################################################################################################################


#################################################################################################################################
/* 1. Создайте двух пользователей которые имеют доступ к базе данных shop. Первому пользователю shop_read должны быть доступны 
 * только запросы на чтение данных, второму пользователю shop — любые операции в пределах базы данных shop.*/
#################################################################################################################################

USE shop;

-- Создаю пользователя shop
CREATE USER shop IDENTIFIED WITH sha256_password BY '**************';

USE mysql;
UPDATE `user`
SET Host = 'localhost'
WHERE User = 'shop';

-- Даю ему все права в таблице shop 
GRANT ALL ON shop.* TO 'shop'@'localhost';

SHOW GRANTS;

-- Создаю пользователя shop_read
CREATE USER shop_read IDENTIFIED WITH sha256_password BY '**************';

USE mysql;
UPDATE `user`
SET Host = 'localhost'
WHERE User = 'shop_read';

-- Даю ему вправа на чтение данных в таблице shop
GRANT USAGE, SELECT ON shop.* TO 'shop_read'@'localhost';

SHOW GRANTS;

#################################################################################################################################
/* 2. (по желанию) Пусть имеется таблица accounts содержащая три столбца id, name, password, содержащие первичный ключ, 
 * имя пользователя и его пароль. Создайте представление username таблицы accounts, предоставляющий доступ к столбцам id и name. 
 * Создайте пользователя user_read, который бы не имел доступа к таблице accounts, однако, мог бы извлекать записи из 
 * представления username.*/
#################################################################################################################################

USE example;
-- Создаю таблицу accounts
CREATE TABLE accounts (
	`id` SERIAL PRIMARY KEY,
	`name` VARCHAR(255),
  	`password` VARCHAR(255)
  );
	
 INSERT INTO accounts (`name`, `password`)
 VALUES
 	('Kate', '123456'),
 	('Tom', '123qwert'),
 	('Helen', 'password'),
 	('Nick', '01011984')
 ;
 
-- Создаю представление
CREATE VIEW username AS SELECT id, name FROM example.accounts;

SELECT * FROM username;-- Представление создано

-- Создаю пользователя user_read
CREATE USER user_read IDENTIFIED WITH sha256_password BY '**************';

USE mysql;
UPDATE `user`
SET Host = 'localhost'
WHERE User = 'user_read';

-- Даю ему вправа на чтение данных (id и name) в представлении username
GRANT USAGE, SELECT ON example.username  TO 'user_read'@'localhost'; 

SELECT * FROM username; -- Запрос выполняется корректно


#################################################################################################################################
#################################################################################################################################
/*Практическое задание по теме “Хранимые процедуры и функции, триггеры"*/
#################################################################################################################################
#################################################################################################################################


#################################################################################################################################
/*  1. Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток. 
 * С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", 
 * с 12:00 до 18:00 функция должна возвращать фразу "Добрый день", 
 * с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи".*/
#################################################################################################################################

-- Создаем функцию
USE example;

DELIMITER //
DROP FUNCTION IF EXISTS hello//
CREATE FUNCTION hello()
RETURNS VARCHAR(255) DETERMINISTIC
BEGIN
	CASE
	WHEN (TIME(NOW()) >= '12:00:00' AND TIME(NOW()) < '17:59:59') THEN 
		RETURN 'Добрый день';
	WHEN (TIME(NOW()) >= '18:00:00' AND TIME(NOW()) < '23:59:59') THEN 
		RETURN 'Добрый вечер';
	ELSE
		RETURN 'Доброе утро';
	END CASE;
END//

-- Вызываем функцию
SELECT TIME(NOW()) AS `Время`, hello() AS `Приветствие`;

#################################################################################################################################
/* 2. В таблице products есть два текстовых поля: name с названием товара и description с его описанием. 
 * Допустимо присутствие обоих полей или одно из них. 
 * Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема. 
 * Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были заполнены. 
 * При попытке присвоить полям NULL-значение необходимо отменить операцию.*/
#################################################################################################################################

USE shop;

-- Создаем триггер, запрещающий вносить новые данные в products, если name и description - NULL
DELIMITER //
DROP TRIGGER IF EXISTS check_null//
CREATE TRIGGER check_null BEFORE INSERT ON products
FOR EACH ROW 
BEGIN
	DECLARE name VARCHAR(255);
	DECLARE description TEXT;
	IF (NEW.name IS NULL AND NEW.description IS NULL) THEN 
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Both columns cannot be null';
	END IF;
END//

-- Проверяем триггер
INSERT INTO shop.products (name, description, price, catalog_id)
VALUES ('Name', 'Материнская плата', 6660.0,2)
; -- Запись прошла

INSERT INTO shop.products (name, price, catalog_id)
VALUES ('Name', 6660.0,2)
; -- Запись прошла

INSERT INTO shop.products (price, catalog_id)
VALUES (6660.0,2)
; -- Выдало ошибку 45000

-- Создаем триггер, запрещающий изменять существующие данные в products, если name и description - NULL
DELIMITER //
DROP TRIGGER IF EXISTS check_null_update//
CREATE TRIGGER check_null_update BEFORE UPDATE ON products
FOR EACH ROW 
BEGIN
	DECLARE name VARCHAR(255);
	DECLARE description TEXT;
	IF (NEW.name IS NULL AND NEW.description IS NULL) THEN 
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Both columns cannot be null';
	END IF;
END//

-- Проверим триггер
UPDATE products 
SET name = 'Name', description = 'Description'
WHERE id = 9
; -- Запись обновилась

UPDATE products 
SET name = NULL, description = 'Description'
WHERE id = 12
; -- Запись обновилась

UPDATE products 
SET name = NULL, description = NULL
WHERE id = 8
; -- Выдало ошибку 45000

#################################################################################################################################
/* 3. (по желанию) Напишите хранимую функцию для вычисления произвольного числа Фибоначчи. 
 * Числами Фибоначчи называется последовательность в которой число равно сумме двух предыдущих чисел. 
 * Вызов функции FIBONACCI(10) должен возвращать число 55.*/
#################################################################################################################################

-- Создаем функцию
USE example;

DELIMITER //
DROP FUNCTION IF EXISTS fibonacci//
CREATE FUNCTION fibonacci(`num` INT)
RETURNS BIGINT DETERMINISTIC
BEGIN
	DECLARE f_num INT DEFAULT 1; -- Первое по порядку число
	DECLARE `val_f` BIGINT DEFAULT 1; -- Значение первого числа
	DECLARE s_num INT DEFAULT 2; -- Второе число
	DECLARE `val_s` BIGINT DEFAULT 1; -- Значение второго числа
	DECLARE `result` BIGINT; -- Результат. Для возможности замены значений 1 и 2 числа через третью переменную
	CASE -- Создаем условия
	WHEN `num` = `f_num` THEN -- Если число num равно первому по порядку числу - то выводим знчение первого числа
		RETURN `val_f`;
	WHEN `num` = `s_num` THEN -- Если число num равно второму по порядку числу - то выводим знчение второго числа
		RETURN `val_s`;
	ELSE -- ИНАЧЕ
		WHILE `s_num` < `num` DO -- Пока второе число меньше num
			SET `result` = `val_f` + `val_s`; -- Через третью переменную присваиваем значение следующему числу (сумма первого и второго)
			SET `val_f` = `val_s`; -- Теперь присваиваем значение второго числа - первому
			SET `val_s` = `result`; -- А значение второго числа возьмем из третьей переменной result
			SET f_num = f_num + 1; -- Увеличим порядковые номера наших чисел
			SET s_num = s_num + 1;
		END WHILE;
		RETURN `val_s`; -- В тот момент, когда s_num будет равен num  - цикл прервется и значение  val_s будет числом Фибоначи нашего num
	END CASE;	
END//

SELECT fibonacci(17) AS 'Число Фибоначи';
